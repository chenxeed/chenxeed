<div class="content-wrapper">
  <h2>VueJS with CycleJS Philosophy</h2>
  <p>
    How is that possible? Here is the proof concept!
  </p>
  <p>
    For the global event from parent to be passed to the children, which is each of
    these cute counters, update this input to restart the counter value.
    <br />
    <input type="number" v-model.number="counterStart" />
    <button v-on:click="emitResetCounter">Reset</button>
  </p>
  <div>
    
    <div class="mdl-grid">
      <div class="mdl-cell mdl-cell--3-col">
        <h3>VueJS Counter Component</h3>
        <vue-counter
          :reset-counter="resetCounter"
          :count-start="counterStart"
          @update:count="vueCounterChange"
          @update:act="vueCounterActionChange"
        />
        <p>
          Can the app listen to the VueJS Counter changes?
          <b>{{ vueCounterMessage }}</b>
        </p>
      </div>
      <div class="mdl-cell mdl-cell--3-col">
        <h3>Cycle Counter Component</h3>
        <cycle-counter
          :reset-counter="resetCounter"
          :count-start="counterStart"
          @update:count="cycleCounterChange"
          @update:act="cycleCounterActionChange"
        />
        <p>
          How about CycleJS App Counter, can I still listen to it?
          <b>{{ cycleCounterMessage }}</b>
          <br/>
          It's wrapped by vue component btw, but just to generate the container.
        </p>
      </div>
      <div class="mdl-cell mdl-cell--3-col">
        <h3>Cycle Based Counter Component</h3>
        <vue-cycle-based-counter class="mdl-cell mdl-cell--6-col"
          :reset-counter="resetCounter"
          :count-start="counterStart"
          @update:count="vueCycleBasedCounterChange"
          @update:act="vueCycleBasedCounterActionChange"
        />
        <p>
          <b>Last to test, can the app listen to it? {{vueCycleBasedCounterMessage}}</b>
          <br />
          It is written in vueJS component, but the way to run the data flow is inspired by CycleJS philosophy, which is to:
          <br />
          <ul>
            <li>use streams for the app logic</li>
            <li>pure functions without any instance</li>
            <li>(absolutely) one way data flow</li>
            <li>Model-View-Intent application flow</li>
            <li>manage the side effect at the end of each flow</li>
          </ul>
        </p>
      </div>
      <div class="mdl-cell mdl-cell--3-col">
        <h3>Cycle Counter Component</h3>
        <vue-cycle-counter class="mdl-cell mdl-cell--6-col"
          :reset-counter="resetCounter"
          :count-start="counterStart"
          @update:count="vueCycleCounterChange"
          @update:act="vueCycleCounterActionChange"
        />
        <p>
          <b>So you still wants to run pure CycleJS App, but with vueJS as the renderer? Here you go! {{vueCycleCounterMessage}}</b>
          <br />
          This Component is using Cycle Run to handle the streams, and then
          it uses vueDriver to connect with the methods of vue Component, which is:
          <ul>
            <li>props : To retrieve the value from parent</li>
            <li>event : To listen to the event from the component itself (DOM listener, etc)</li>
            <li>data : To modify the data() of vue, to update the template</li>
            <li>emit : To emit event from the component, that is susbcribed by its parent</li>
          </ul>
        </p>
      </div>
    </div>
  </div>
</div>